{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020-11-16-manage-schema-evolution-in-serverless-stack/","result":{"data":{"site":{"siteMetadata":{"title":"Dev Blog","author":"Arek Jurasz"}},"markdownRemark":null},"pageContext":{"slug":"/2020-11-16-manage-schema-evolution-in-serverless-stack/","previous":{"fields":{"slug":"/2020-04-12-continuous-deployment-on-kubernetes/"},"html":"<p>If you are wondering how could you set up your build pipeline to do a deployment of your application to Kubernetes cluster then you can find this post interesting.</p>\n<!-- end -->\n<h2>Disclaimer</h2>\n<p>Everything that will be presented in this blog post was only used for Test and QA environments as a way to learn more about Kubernetes. It was not used for Prod environment yet so please keep this in your mind.</p>\n<h2>Stack</h2>\n<p>Before moving to details itâ€™s worth mentioning what I have to disposal:</p>\n<ul>\n<li>Kubernetes cluster</li>\n<li>Jenkins pipeline job</li>\n<li>Private Docker registry</li>\n<li>Dockerized application</li>\n</ul>\n<h2>Build</h2>\n<p>Since Jenkins pipeline job is in place then the deployment is as easy as adding a new stage to an existing job pipeline. I have called mine <code class=\"language-text\">Deploy</code>. This stage is responsible for the following:</p>\n<ul>\n<li>run only on <code class=\"language-text\">develop</code> branch</li>\n<li>build docker image</li>\n<li>push the docker image to a repository</li>\n<li>call <a href=\"https://jenkins.io/doc/pipeline/steps/kubernetes-cd/#kubernetes-continuous-deploy-plugin\">Kubernetes Continuous Deploy Plugin</a></li>\n<li>remove docker image from Jenkins worker (just to save space)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pipeline {\n    stages {\n        stage(&#39;Deploy&#39;) {\n            when {\n                branch &quot;develop&quot;\n            }\n\n            environment {\n                DOCKER_REPOSITORY = &#39;127.0.0.1:5000&#39;\n                IMAGE_NAME = &#39;app&#39;\n                IMAGE_TAG = sh(script: &quot;git log -1 --pretty=%h&quot;undefined returnStdout: true).trim()\n                APP_IMAGE = &quot;${DOCKER_REPOSITORY}/${IMAGE_NAME}:${IMAGE_TAG}&quot;\n            }\n\n            steps {\n                sh &quot;&quot;&quot;\n                docker build -t ${APP_IMAGE} ./docker\n                &quot;&quot;&quot;\n\n                sh &quot;&quot;&quot;\n                docker push ${APP_IMAGE}\n                &quot;&quot;&quot;\n\n                kubernetesDeploy(kubeconfigId: &#39;k8s-config&#39;undefined configs: &#39;**/k8s/qa/app.yml&#39;)\n            }\n\n            post {\n                always {\n                    sh &quot;&quot;&quot;\n                    docker rmi ${APP_IMAGE}\n                    &quot;&quot;&quot;\n                }\n            }\n        }\n    }\n}</code></pre></div>\n<p>In the above snippet, there are two important things to notice. First is the registration of environment variable with name <code class=\"language-text\">APP_IMAGE</code>. The second most important thing is that kubernetes-cd plugin can substitute variables in the form of <code class=\"language-text\">${APP_IMAGE}</code> in the configuration file (<code class=\"language-text\">app.yml</code>) with variables from Jenkins environment. This is the default behaviour of the plugin and can be disabled with <code class=\"language-text\">enableConfigSubstitution</code> set to <code class=\"language-text\">false</code>.</p>\n<p>Kubernetes configuration consists of the standard objects needed for deploying an application to the cluster</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-qa\n  labels:\n    app: app-qa\n    env: qa\nspec:\n  replicas: 1\n  revisionHistoryLimit: 1\n  selector:\n    matchLabels:\n      app: app-qa\n      env: qa\n  template:\n    metadata:\n      labels:\n        app: app-qa\n        env: qa\n    spec:\n      containers:\n        - name: app-qa\n          image: ${APP_IMAGE}\n          imagePullPolicy: &quot;IfNotPresent&quot;\n          ports:\n            - containerPort: 8080\n          env:\n            - name: SPRING_PROFILES_ACTIVE\n              value: qa\n          resources:\n            limits:\n              cpu: 500m\n              memory: 256Mi\n            requests:\n              cpu: 500m\n              memory: 256Mi\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: app-qa\n  labels:\n    app: app-qa\n    env: qa\nspec:\n  type: NodePort\n  ports:\n    - port: 8080\n      nodePort: 31000\n  selector:\n    app: app-qa\n    env: qa</code></pre></div>\n<p>When the above configuration is applied then Kubernetes only updates these object that did change. So in case of successive deployment, only <code class=\"language-text\">Deployment</code> object is updated which represents our application. <code class=\"language-text\">revisionHistoryLimit</code> is an extra configuration which keeps previous <code class=\"language-text\">Deployment</code> object just in case if rollback is necessary.</p>","frontmatter":{"title":"Continuous Deployment on Kubernetes","date":"April 12, 2020"}},"next":null}}}